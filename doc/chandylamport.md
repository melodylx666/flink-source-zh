### 分布式快照

所谓分布式快照，就是在特定时间点记录下来的分布式系统的全局状态，这个全局状态既包含所有进程的状态也包括链路的状态，主要用于分布式系统的故障
恢复、死锁检测和垃圾收集等。由于链路本身只负责传递消息，其状态不容易被记录，所以很难在同一瞬间捕捉所有进程和链路的状态，而Chandy-Lamport
算法则通过`每个进程记录与自己相关的状态`，并最终合并出全局状态来达到了同样的效果。

假设分布式系统有如下三部分组成：
* 节点进程i
* 节点进程j
* 信道进程Cij

如果要对此系统做快照，则最简单的是分别的三个进程保存状态。但是有如下问题：

* 系统无法全部暂停
* 发送消息可能不同步。比如节点i和信道Cij同时收到消息，进行快照，而j后收到消息，已经消费完Cij的msg了才进行快照。则此时信道Cij的msg就被重复消费了。

而Chandy-Lpamport算法可以解决上述问题。

该算法可以分成3个阶段，下面分别进行描述：

* 系统中的任何一个节点都可以发起快照操作。
* 对于发起快照 操作的节点 i:
  
   * 节点i对本地进程生成快照
   * 向其他所有节点发送`Marker`消息
   * 对于流入信道的消息生成快照
   * 如果此节点收到了从Node j (j != i)发送过来的一条`Marker`消息，则停止记录信道Node j->Node i上的消息。
 * 对于其他节点Node j (j != i)
   * 如果Node j第一次从信道Ck->j (k != j)上收到了`Marker`消息，则对本地进程生成快照，然后给所有其他节点发送一条`Marker`消息
   * 对于所有从其他节点l (l != k)发送过来的消息，和本地快照一并记录下来
   * 如果此节点上收到了从Node l (l != k)发送过来的一条`Marker`消息，则停止记录信道Node l->Node j上的消息。
 * 当所有的节点都从其他节点收到了`Marker`以后，算法停止，分布式系统的快照生成完成
 * 在一个系统中可以有多个快照同时进行，发起节点也可以不同，只要在发起快照时给它赋予一个全局唯一的ID，然后发起节点把这个ID附在`Marker`消息上，同时每个节点在做本地快照时在快照副本上记录这是对于哪一个ID生成的副本，然后也把ID附在发送出的`Marker`消息上.

这就是Chandy-Lamport分布式快照的实现原理。

Flink以该算法为基础，实现了异步屏障快照算法。简单的说，Flink的JobManager会周期性的向每个SourceTask发送一条包含一个新checkpointId
的消息，间隔时间由配置env.enableCheckpointing(间隔时间毫秒)控制，以初始化一个checkpoint。当SourceTask收到这条消息时就会停止向下游发送
消息，广播一种特殊的记录checkpoint barrier(作用类似于Chandy-Lamport算法中的特殊标记信息)，并在StateBackend生成一个包含本地状态的checkpoint。


Flink内部的分布式快照机制如下：

1. 作业状态初始化
2. 数据流入
3. 执行快照。
   1. 此时JobManager触发执行快照，并将命令发送给所有节点的SubTask。
   2. Source算子的Subtask：收到命令停止处理数据，保存本地状态，向所有下游算子发送barrier。
   3. KeyBy/Reduce算子的Subtask：收到命令后，将上游的每个信道数据依旧收集，直到该信道的barrier传入。然后向所有下游发送barrier,并本地保存状态。
   4. Sink算子的Subtask：收到命令之后停止处理数据。然后收到上游barrier之后，将信道数据持久化到状态后端中。
4. 快照完成，JobMannager收到所有的subtask都执行完毕，则一次checkpoint完成。

